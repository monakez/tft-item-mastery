import{j as e,i as t,v as s,T as i,k as n,l as r,m as a,R as o,n as h,o as l,p as c,C as d,q as u,r as p,s as f,w as g,g as m}from"./index-eJpqKaHf.js";class x extends e{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return t(s,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return t(s,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return t(s,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return t(s,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return t(s,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(e=!1){this.emit("destroy",this),this.removeAllListeners();for(const t in this.chars)this.chars[t].texture?.destroy();this.chars=null,e&&(this.pages.forEach(e=>e.texture.destroy(!0)),this.pages=null)}}const w=class e extends x{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const s={...e.defaultOptions,...t};this._textureSize=s.textureSize,this._mipmap=s.mipmap;const o=s.style.clone();s.overrideFill&&(o._fill.color=16777215,o._fill.alpha=1,o._fill.texture=i.WHITE,o._fill.fill=null),this.applyFillAsTint=s.overrideFill;const h=o.fontSize;o.fontSize=this.baseMeasurementFontSize;const l=n(o);s.overrideSize?o._stroke&&(o._stroke.width*=this.baseRenderedFontSize/h):o.fontSize=this.baseRenderedFontSize=h,this._style=o,this._skipKerning=s.skipKerning??!1,this.resolution=s.resolution??1,this._padding=s.padding??4,s.textureStyle&&(this._textureStyle=s.textureStyle instanceof r?s.textureStyle:new r(s.textureStyle)),this.fontMetrics=a.measureFont(l),this.lineHeight=o.lineHeight||this.fontMetrics.fontSize||o.fontSize}ensureCharacters(e){const t=a.graphemeSegmenter(e).filter(e=>!this._currentChars.includes(e)).filter((e,t,s)=>s.indexOf(e)===t);if(!t.length)return;let s;this._currentChars=[...this._currentChars,...t],s=-1===this._currentPageIndex?this._nextPage():this.pages[this._currentPageIndex];let{canvas:n,context:r}=s.canvasAndContext,h=s.texture.source;const l=this._style;let c=this._currentX,d=this._currentY,u=this._currentMaxCharHeight;const p=this.baseRenderedFontSize/this.baseMeasurementFontSize,f=this._padding*p;let g=!1;const m=n.width/this.resolution,x=n.height/this.resolution;for(let w=0;w<t.length;w++){const e=t[w],s=a.measureText(e,l,n,!1);s.lineHeight=s.height;const y=s.width*p,_=Math.ceil(("italic"===l.fontStyle?2:1)*y)+2*f,S=s.height*p+2*f;if(g=!1,"\n"!==e&&"\r"!==e&&"\t"!==e&&" "!==e&&(g=!0,u=Math.ceil(Math.max(S,u))),c+_>m&&(d+=u,u=S,c=0,d+u>x)){h.update();const e=this._nextPage();n=e.canvasAndContext.canvas,r=e.canvasAndContext.context,h=e.texture.source,c=0,d=0,u=0}const F=y/p-(l.dropShadow?.distance??0)-(l._stroke?.width??0);if(this.chars[e]={id:e.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:F,kerning:{}},g){this._drawGlyph(r,s,c+f,d+f,p,l);const t=h.width*p,n=h.height*p,a=new o(c/t*h.width,d/n*h.height,_/t*h.width,S/n*h.height);this.chars[e].texture=new i({source:h,frame:a}),c+=Math.ceil(_)}}h.update(),this._currentX=c,this._currentY=d,this._currentMaxCharHeight=u,this._skipKerning&&this._applyKerning(t,r)}get pageTextures(){return t(s,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(e,t){const s=this._measureCache;for(let i=0;i<e.length;i++){const n=e[i];for(let e=0;e<this._currentChars.length;e++){const i=this._currentChars[e];let r=s[n];r||(r=s[n]=t.measureText(n).width);let a=s[i];a||(a=s[i]=t.measureText(i).width);let o=t.measureText(n+i).width,h=o-(r+a);h&&(this.chars[n].kerning[i]=h),o=t.measureText(n+i).width,h=o-(r+a),h&&(this.chars[i].kerning[n]=h)}}}_nextPage(){this._currentPageIndex++;const e=this.resolution,t=h.getOptimalCanvasAndContext(this._textureSize,this._textureSize,e);this._setupContext(t.context,this._style,e);const s=e*(this.baseRenderedFontSize/this.baseMeasurementFontSize),n=new i({source:new l({resource:t.canvas,resolution:s,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(n.source.style=this._textureStyle);const r={canvasAndContext:t,texture:n};return this.pages[this._currentPageIndex]=r,r}_setupContext(e,t,s){t.fontSize=this.baseRenderedFontSize,e.scale(s,s),e.font=n(t),t.fontSize=this.baseMeasurementFontSize,e.textBaseline=t.textBaseline;const i=t._stroke,r=i?.width??0;if(i&&(e.lineWidth=r,e.lineJoin=i.join,e.miterLimit=i.miterLimit,e.strokeStyle=c(i,e)),t._fill&&(e.fillStyle=c(t._fill,e)),t.dropShadow){const i=t.dropShadow,n=d.shared.setValue(i.color).toArray(),r=i.blur*s,a=i.distance*s;e.shadowColor=`rgba(${255*n[0]},${255*n[1]},${255*n[2]},${i.alpha})`,e.shadowBlur=r,e.shadowOffsetX=Math.cos(i.angle)*a,e.shadowOffsetY=Math.sin(i.angle)*a}else e.shadowColor="black",e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0}_drawGlyph(e,t,s,i,n,r){const a=t.text,o=t.fontProperties,h=r._stroke,l=(h?.width??0)*n,c=s+l/2,d=i-l/2,u=o.descent*n,p=t.lineHeight*n;let f=!1;r.stroke&&l&&(f=!0,e.strokeText(a,c,d+p-u));const{shadowBlur:g,shadowOffsetX:m,shadowOffsetY:x}=e;r._fill&&(f&&(e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0),e.fillText(a,c,d+p-u)),f&&(e.shadowBlur=g,e.shadowOffsetX=m,e.shadowOffsetY=x)}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{canvasAndContext:t,texture:s}=this.pages[e];h.returnCanvasAndContext(t),s.destroy(!0)}this.pages=null}};w.defaultOptions={textureSize:512,style:new u,mipmap:!0};let y=w;let _=0;const S=new class{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=p(1e3)}getFont(e,t){let s=`${t.fontFamily}-bitmap`,i=!0;if(t._fill.fill&&!t._stroke?(s+=t._fill.fill.styleKey,i=!1):(t._stroke||t.dropShadow)&&(s=`${t.styleKey}-bitmap`,i=!1),!f.has(s)){const e=Object.create(t);e._lineHeight=0;const n=new y({style:e,overrideFill:i,overrideSize:!0,...this.defaultOptions});_++,_>50&&g("BitmapText",`You have dynamically created ${_} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),n.once("destroy",()=>{_--,f.remove(s)}),f.set(s,n)}const n=f.get(s);return n.ensureCharacters?.(e),n}getLayout(e,t,s=!0){const i=this.getFont(e,t),n=`${e}-${t.styleKey}-${s}`;if(this.measureCache.has(n))return this.measureCache.get(n);const r=function(e,t,s,i){const n={width:0,height:0,offsetY:0,scale:t.fontSize/s.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};n.offsetY=s.baseLineOffset;let r=n.lines[0],a=null,o=!0;const h={width:0,start:0,index:0,positions:[],chars:[]},l=s.baseMeasurementFontSize/t.fontSize,c=t.letterSpacing*l,d=t.wordWrapWidth*l,u=t.lineHeight?t.lineHeight*l:s.lineHeight,p=t.wordWrap&&t.breakWords,f=e=>{const t=r.width;for(let s=0;s<h.index;s++){const i=e.positions[s];r.chars.push(e.chars[s]),r.charPositions.push(i+t)}r.width+=e.width,o=!1,h.width=0,h.index=0,h.chars.length=0},g=()=>{let e=r.chars.length-1;if(i){let t=r.chars[e];for(;" "===t;)r.width-=s.chars[t].xAdvance,t=r.chars[--e]}n.width=Math.max(n.width,r.width),r={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},o=!0,n.lines.push(r),n.height+=u},m=e=>e-c>d;for(let x=0;x<e.length+1;x++){let i;const n=x===e.length;n||(i=e[x]);const l=s.chars[i]||s.chars[" "];if(/(?:\s)/.test(i)||"\r"===i||"\n"===i||n){if(!o&&t.wordWrap&&m(r.width+h.width)?(g(),f(h),n||r.charPositions.push(0)):(h.start=r.width,f(h),n||r.charPositions.push(0)),"\r"===i||"\n"===i)g();else if(!n){const e=l.xAdvance+(l.kerning[a]||0)+c;r.width+=e,r.spaceWidth=e,r.spacesIndex.push(r.charPositions.length),r.chars.push(i)}}else{const e=l.kerning[a]||0,t=l.xAdvance+e+c;p&&m(r.width+h.width+t)&&(f(h),g()),h.positions[h.index++]=h.width+e,h.chars.push(i),h.width+=t}a=i}return g(),"center"===t.align?function(e){for(let t=0;t<e.lines.length;t++){const s=e.lines[t],i=e.width/2-s.width/2;for(let e=0;e<s.charPositions.length;e++)s.charPositions[e]+=i}}(n):"right"===t.align?function(e){for(let t=0;t<e.lines.length;t++){const s=e.lines[t],i=e.width-s.width;for(let e=0;e<s.charPositions.length;e++)s.charPositions[e]+=i}}(n):"justify"===t.align&&function(e){const t=e.width;for(let s=0;s<e.lines.length;s++){const i=e.lines[s];let n=0,r=i.spacesIndex[n++],a=0;const o=i.spacesIndex.length,h=(t-i.width)/o;for(let e=0;e<i.charPositions.length;e++)e===r&&(r=i.spacesIndex[n++],a+=h),i.charPositions[e]+=a}}(n),n}(a.graphemeSegmenter(e),t,i,s);return this.measureCache.set(n,r),r}measureText(e,t,s=!0){return this.getLayout(e,t,s)}install(...e){let i=e[0];"string"==typeof i&&(i={name:i,style:e[1],chars:e[2]?.chars,resolution:e[2]?.resolution,padding:e[2]?.padding,skipKerning:e[2]?.skipKerning},t(s,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const n=i?.name;if(!n)throw new Error("[BitmapFontManager] Property `name` is required.");i={...this.defaultOptions,...i};const r=i.style,a=r instanceof u?r:new u(r),o=i.dynamicFill??this._canUseTintForStyle(a),h=new y({style:a,overrideFill:o,skipKerning:i.skipKerning,padding:i.padding,resolution:i.resolution,overrideSize:!1,textureStyle:i.textureStyle}),l=function(e){if(""===e)return[];"string"==typeof e&&(e=[e]);const t=[];for(let s=0,i=e.length;s<i;s++){const i=e[s];if(Array.isArray(i)){if(2!==i.length)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);if(0===i[0].length||0===i[1].length)throw new Error("[BitmapFont]: Invalid character delimiter.");const e=i[0].charCodeAt(0),s=i[1].charCodeAt(0);if(s<e)throw new Error("[BitmapFont]: Invalid character range.");for(let i=e,n=s;i<=n;i++)t.push(String.fromCharCode(i))}else t.push(...Array.from(i))}if(0===t.length)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}(i.chars);return h.ensureCharacters(l.join("")),f.set(`${n}-bitmap`,h),h.once("destroy",()=>f.remove(`${n}-bitmap`)),h}uninstall(e){const t=`${e}-bitmap`,s=f.get(t);s&&s.destroy()}_canUseTintForStyle(e){return!(e._stroke||e.dropShadow&&0!==e.dropShadow.color||e._fill.fill||16777215!==e._fill.color)}};class F extends x{constructor(e,t){super();const{textures:s,data:n}=e;Object.keys(n.pages).forEach(e=>{const t=n.pages[parseInt(e,10)],i=s[t.id];this.pages.push({texture:i})}),Object.keys(n.chars).forEach(e=>{const t=n.chars[e],{frame:r,source:a,rotate:h}=s[t.page],l=m.transformRectCoords(t,r,h,new o),c=new i({frame:l,orig:new o(0,0,t.width,t.height),source:a,rotate:h});this.chars[e]={id:e.codePointAt(0),xOffset:t.xOffset,yOffset:t.yOffset,xAdvance:t.xAdvance,kerning:t.kerning??{},texture:c}}),this.baseRenderedFontSize=n.fontSize,this.baseMeasurementFontSize=n.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:n.fontSize},this.baseLineOffset=n.baseLineOffset,this.lineHeight=n.lineHeight,this.fontFamily=n.fontFamily,this.distanceField=n.distanceField??{type:"none",range:0},this.url=t}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{texture:t}=this.pages[e];t.destroy(!0)}this.pages=null}static install(e){S.install(e)}static uninstall(e){S.uninstall(e)}}export{F as BitmapFont};
