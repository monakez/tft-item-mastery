import{b as t,T as n,G as e,a as o,C as r,t as i,P as a,u}from"./index-eJpqKaHf.js";import{F as l}from"./Filter-Cw1r2BT3.js";import{G as s}from"./Graphics-B04i3yF2.js";class c extends t{constructor(t,e=64,o=64){super(n.EMPTY),this.item=t,this.width=e,this.height=o,this.texture=n.from(`/tft-item-mastery/items/${t.icon}`)}updateData(t){this.item=t,this.texture=n.from(`/tft-item-mastery/items/${t.icon}`),this.glow&&(this.glow.outerStrength=0)}setPosition(t,n){return this.position.set(t,n),this}makeInteractive(){return this.interactive=!0,this.cursor="pointer",this}}var h=Object.defineProperty,g=(t,n,e)=>(((t,n,e)=>{n in t?h(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e})(t,"symbol"!=typeof n?n+"":n,e),e);const p=class t extends l{constructor(n){const i=(n={...t.DEFAULT_OPTIONS,...n}).distance??10,a=n.quality??.1;super({gpuProgram:e.from({vertex:{source:"struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}",entryPoint:"mainVertex"},fragment:{source:"struct GlowUniforms {\n  uDistance: f32,\n  uStrength: vec2<f32>,\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uQuality: f32,\n  uKnockout: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let quality = glowUniforms.uQuality;\n  let distance = glowUniforms.uDistance;\n\n  let dist: f32 = glowUniforms.uDistance;\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\n\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\n\n  var totalAlpha: f32 = 0.0;\n\n  var direction: vec2<f32>;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n      curColor = textureSample(uTexture, uSampler, displaced);\n      totalAlpha += (dist - curDistance) * curColor.a;\n    }\n  }\n    \n  curColor = textureSample(uTexture, uSampler, uv);\n\n  let glowColorRGB = glowUniforms.uColor;\n  let glowAlpha = glowUniforms.uAlpha;\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\n  let innerStrength = glowUniforms.uStrength[0];\n  let outerStrength = glowUniforms.uStrength[1];\n\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\n  \n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\n  \n  if (knockout) {\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\n  }\n  else {\n    return innerColor + outerGlowColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;",entryPoint:"mainFragment"}}),glProgram:o.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uStrength;\nuniform vec3 uColor;\nuniform float uKnockout;\nuniform float uAlpha;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159265358979323846264;\n\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\n\nvoid main(void) {\n    vec2 px = vec2(1.) / uInputSize.xy;\n\n    float totalAlpha = 0.;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\n      direction = vec2(cos(angle), sin(angle)) * px;\n\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\n          curColor = texture(uTexture, displaced);\n          totalAlpha += (DIST - curDistance) * curColor.a;\n      }\n    }\n    \n    curColor = texture(uTexture, vTextureCoord);\n\n    vec4 glowColor = vec4(uColor, uAlpha);\n    bool knockout = uKnockout > .5;\n    float innerStrength = uStrength[0];\n    float outerStrength = uStrength[1];\n\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\n    float innerGlowStrength = min(1., innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n\n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      finalColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi,`${(1/a/i).toFixed(7)}`).replace(/__DIST__/gi,`${i.toFixed(0)}.0`),name:"glow-filter"}),resources:{glowUniforms:{uDistance:{value:i,type:"f32"},uStrength:{value:[n.innerStrength,n.outerStrength],type:"vec2<f32>"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:n.alpha,type:"f32"},uQuality:{value:a,type:"f32"},uKnockout:{value:n?.knockout?1:0,type:"f32"}}},padding:i}),g(this,"uniforms"),g(this,"_color"),this.uniforms=this.resources.glowUniforms.uniforms,this._color=new r,this.color=n.color??16777215}get distance(){return this.uniforms.uDistance}set distance(t){this.uniforms.uDistance=this.padding=t}get innerStrength(){return this.uniforms.uStrength[0]}set innerStrength(t){this.uniforms.uStrength[0]=t}get outerStrength(){return this.uniforms.uStrength[1]}set outerStrength(t){this.uniforms.uStrength[1]=t}get color(){return this._color.value}set color(t){this._color.setValue(t);const[n,e,o]=this._color.toArray();this.uniforms.uColor[0]=n,this.uniforms.uColor[1]=e,this.uniforms.uColor[2]=o}get alpha(){return this.uniforms.uAlpha}set alpha(t){this.uniforms.uAlpha=t}get quality(){return this.uniforms.uQuality}set quality(t){this.uniforms.uQuality=t}get knockout(){return 1===this.uniforms.uKnockout}set knockout(t){this.uniforms.uKnockout=t?1:0}};g(p,"DEFAULT_OPTIONS",{distance:10,outerStrength:4,innerStrength:0,color:16777215,alpha:1,quality:.1,knockout:!1});let f=p;class m extends i{constructor(t,n){super(),this.ctx=t,this.onCombine=n,this.draggingSprite=null,this.dragOffset={x:0,y:0},this.baseSprites=[],this.drawItems(),this.disableGlow()}glow(t){const n=this.baseSprites.filter(n=>n?.item?.id===t&&0===n?.glow?.outerStrength);n[0]?.glow&&(n[0].glow.outerStrength=2)}disableGlow(){this.baseSprites.forEach(t=>{t.glow.outerStrength=0})}drawItems(){const t=this.ctx.currentSet?.base||[],n=[...t,...t].sort(()=>Math.random()-.5),e=Math.ceil(n.length/2),o=((this.parent?.width||this.ctx.app.screen.width)-(85*e-15))/2;this.baseSprites.forEach(t=>{t.off(),t.destroy({children:!0,texture:!1})}),this.baseSprites=[],n.forEach((t,n)=>{const e=Math.floor(n/2),r=o+85*e,i=0+85*(n%2),a=new c(t,70,70).makeInteractive().setPosition(r,i);a.originalX=r,a.originalY=i,a.on("pointerdown",this.onDragStart,this).on("globalpointermove",this.onDragMove,this).on("pointerup",this.onDragEnd,this).on("pointerupoutside",this.onDragEnd,this),this.addChild(a),this.baseSprites.push(a),this.applyGlowFilter(a)})}applyGlowFilter(t){const n=new f({distance:5,outerStrength:0,innerStrength:0,color:30464,quality:1});t.glow=n,t.filters=[n]}onDragStart(t){const n=t.currentTarget;this.draggingSprite=n,this.dragOffset={x:t.global.x-n.x,y:t.global.y-n.y},n.cursor="grabbing",n.alpha=.8,this.addChild(n)}onDragMove(t){this.draggingSprite&&(this.draggingSprite.x=t.global.x-this.dragOffset.x,this.draggingSprite.y=t.global.y-this.dragOffset.y)}onDragEnd(){if(!this.draggingSprite)return;const t=this.draggingSprite;t.alpha=1,t.cursor="grab";let n=null;for(const a of this.baseSprites)if(a!==t&&this.isColliding(t,a)){n=a;break}if(this.draggingSprite=null,!n)return t.x=t.originalX,void(t.y=t.originalY);const e=new a((t.x+n.x)/2,(t.y+n.y)/2),o=this.toGlobal(e),r={x:o.x,y:o.y},i=this.combineItems(t.item,n.item);t.x=t.originalX,t.y=t.originalY,this.onCombine&&i&&this.onCombine({itemA:t.item,itemB:n.item,result:i,position:r})}isColliding(t,n){const e=t.getBounds(),o=n.getBounds();return e.x+e.width>o.x&&e.x<o.x+o.width&&e.y+e.height>o.y&&e.y<o.y+o.height}combineItems(t,n){const e=[t.id,n.id].sort(),o=this.ctx.currentSet.findItemByRecipe(e)||this.ctx.sets.all.findItemByRecipe(e);if(!o)throw new Error("recipe not found");return o}destroy(){super.destroy({children:!0})}}const d=96;class v extends u{constructor(t){super(t);this.hudContainer=new i,this.gameAreaContainer=new i,this.container.addChild(this.hudContainer,this.gameAreaContainer),this.gameArea={x:0,y:0,width:this.ctx.app.screen.width,height:.5*this.ctx.app.screen.height};const{width:n,height:e}=t.app.screen,o=(new s).rect(0,0,this.gameArea.width,this.gameArea.height).fill({color:1710638,alpha:.7}),r=(new s).moveTo(0,this.gameArea.height).lineTo(this.gameArea.width,this.gameArea.height).stroke({width:2,color:4473958});this.gameAreaContainer.addChild(o,r);const a=(new s).rect(0,.8*e,n,.2*e).fill({color:1450302,alpha:.9});this.hudContainer.addChild(a),this.createCommonHud(),this.hudContainer.y=.5*e}createCommonHud(){this.dragPanel=new m(this.ctx,t=>this.onCombine(t)),this.hudContainer.addChild(this.dragPanel)}onCombine(t){const n=new c(t.result,96,96);n.x=t.position.x,n.y=t.position.y,this.gameAreaContainer.addChild(n);const e=this.findTargetTftItem(t.result);if(e){const o=e.getGlobalPosition();this.animateToTarget(n,()=>({x:o.x,y:o.y}),()=>this.onHit(t.result,e))}else this.animateToTarget(n,()=>({x:0,y:0}),()=>this.onMiss(t.result))}animateToTarget(t,n,e){let o=0;const r=()=>{const i=this.ctx.app.ticker.deltaMS;o=Math.min(o+.02*i,1.5);const a=n(),u=a.x,l=a.y,s=u-t.x,c=l-t.y,h=Math.sqrt(s*s+c*c),g=o*i;if(h<=g&&h>0)t.x=u,t.y=l,this.ctx.app.ticker.remove(r),e(),setTimeout(()=>{t.parent&&t.destroy()},100);else{const n=g/h;t.x+=s*n,t.y+=c*n}};this.ctx.app.ticker.add(r)}onHit(t,n){}onMiss(){}findTargetTftItem(t){return null}}export{v as G,c as T,d as a};
