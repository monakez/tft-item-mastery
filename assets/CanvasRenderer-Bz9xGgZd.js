import{g as e,J as t,K as n,M as a,E as s,w as r,C as o,T as i,L as l,N as c,O as h,Q as d,U as u,W as p,D as m,X as g,Y as x,e as f}from"./index-eJpqKaHf.js";import{R as v,S as y,B as T,a as C,b as _,c as k,A as b,C as P}from"./RenderTargetSystem-BqlQ5hJi.js";import{c as M,a as w}from"./canvasUtils-f2nCwI2T.js";import{G as S}from"./Graphics-B04i3yF2.js";import"./Filter-Cw1r2BT3.js";import"./colorToUniform-DIWNkBfR.js";const I=class a{static _getPatternRepeat(e,t){const n=e&&"clamp-to-edge"!==e,a=t&&"clamp-to-edge"!==t;return n&&a?"repeat":n?"repeat-x":a?"repeat-y":"no-repeat"}start(e,t,n){}execute(s,r){const o=r.elements;if(!o||!o.length)return;const i=s.renderer,l=i.canvasContext,c=l.activeContext;for(let h=0;h<o.length;h++){const s=o[h];if(!s.packAsQuad)continue;const d=s,u=d.texture,p=u?M.getCanvasSource(u):null;if(!p)continue;const m=u.source.style,g=l.smoothProperty,x="nearest"!==m.scaleMode;c[g]!==x&&(c[g]=x),l.setBlendMode(r.blendMode);const f=i.globalUniforms.globalUniformData?.worldColor??4294967295,v=d.color,y=(f>>>24&255)/255*((v>>>24&255)/255)*(i.filter?.alphaMultiplier??1);if(y<=0)continue;c.globalAlpha=y;const T=t(n(16777215&v,16777215&f)),C=u.frame,_=m.addressModeU??m.addressMode,k=m.addressModeV??m.addressMode,b=a._getPatternRepeat(_,k),P=u.source._resolution??u.source.resolution??1,w=d.renderable?.renderGroup?.isCachedAsTexture,S=C.x*P,I=C.y*P,R=C.width*P,B=C.height*P,A=d.bounds,E=i.renderTarget.renderTarget.isRoot,W=A.minX,H=A.minY,G=A.maxX-A.minX,U=A.maxY-A.minY,j=u.rotate,F=u.uvs,q=Math.min(F.x0,F.x1,F.x2,F.x3,F.y0,F.y1,F.y2,F.y3),D=Math.max(F.x0,F.x1,F.x2,F.x3,F.y0,F.y1,F.y2,F.y3),O="no-repeat"!==b&&(q<0||D>1),L=j&&!(!O&&(16777215!==T||j));L?(a._tempPatternMatrix.copyFrom(d.transform),e.matrixAppendRotationInv(a._tempPatternMatrix,j,W,H,G,U),l.setContextTransform(a._tempPatternMatrix,1===d.roundPixels,void 0,w&&E)):l.setContextTransform(d.transform,1===d.roundPixels,void 0,w&&E);const N=L?0:W,Y=L?0:H,V=G,X=U;if(O){let e=p;const t=16777215!==T&&!j,n=C.width<=u.source.width&&C.height<=u.source.height;t&&n&&(e=M.getTintedCanvas({texture:u},T));const s=c.createPattern(e,b);if(!s)continue;const r=V,o=X;if(0===r||0===o)continue;const i=1/r,l=1/o,h=(F.x1-F.x0)*i,d=(F.y1-F.y0)*i,m=(F.x3-F.x0)*l,g=(F.y3-F.y0)*l,x=F.x0-h*N-m*Y,f=F.y0-d*N-g*Y,v=u.source.pixelWidth,y=u.source.pixelHeight;a._tempPatternMatrix.set(h*v,d*y,m*v,g*y,x*v,f*y),M.applyPatternTransform(s,a._tempPatternMatrix),c.fillStyle=s,c.fillRect(N,Y,V,X)}else{const e=16777215!==T||j?M.getTintedCanvas({texture:u},T):p,t=e!==p;c.drawImage(e,t?0:S,t?0:I,t?e.width:R,t?e.height:B,N,Y,V,X)}}}};I._tempPatternMatrix=new a,I.extension={type:[s.CanvasPipesAdaptor],name:"batch"};let R=I;class B{constructor(e){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=e}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(e,t,n){this._renderer.renderPipes.batch.break(n);const a=this._colorStack;a[this._colorStackIndex]=a[this._colorStackIndex-1]&e.mask;const s=this._colorStack[this._colorStackIndex];s!==this._currentColor&&(this._currentColor=s,n.add({renderPipeId:"colorMask",colorMask:s,canBundle:!1})),this._colorStackIndex++}pop(e,t,n){this._renderer.renderPipes.batch.break(n);const a=this._colorStack;this._colorStackIndex--;const s=a[this._colorStackIndex-1];s!==this._currentColor&&(this._currentColor=s,n.add({renderPipeId:"colorMask",colorMask:s,canBundle:!1}))}execute(e){}destroy(){this._renderer=null,this._colorStack=null}}function A(e,t){switch(t.type){case"rectangle":{const n=t;e.rect(n.x,n.y,n.width,n.height);break}case"roundedRectangle":{const n=t;!function(e,t,n,a,s,r){r=Math.max(0,Math.min(r,Math.min(a,s)/2)),e.moveTo(t+r,n),e.lineTo(t+a-r,n),e.quadraticCurveTo(t+a,n,t+a,n+r),e.lineTo(t+a,n+s-r),e.quadraticCurveTo(t+a,n+s,t+a-r,n+s),e.lineTo(t+r,n+s),e.quadraticCurveTo(t,n+s,t,n+s-r),e.lineTo(t,n+r),e.quadraticCurveTo(t,n,t+r,n)}(e,n.x,n.y,n.width,n.height,n.radius);break}case"circle":{const n=t;e.moveTo(n.x+n.radius,n.y),e.arc(n.x,n.y,n.radius,0,2*Math.PI);break}case"ellipse":{const n=t;e.ellipse?(e.moveTo(n.x+n.halfWidth,n.y),e.ellipse(n.x,n.y,n.halfWidth,n.halfHeight,0,0,2*Math.PI)):(e.save(),e.translate(n.x,n.y),e.scale(n.halfWidth,n.halfHeight),e.moveTo(1,0),e.arc(0,0,1,0,2*Math.PI),e.restore());break}case"triangle":{const n=t;e.moveTo(n.x,n.y),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3),e.closePath();break}default:{const n=t,a=n.points;if(!a?.length)break;e.moveTo(a[0],a[1]);for(let t=2;t<a.length;t+=2)e.lineTo(a[t],a[t+1]);n.closePath&&e.closePath();break}}}function E(e,t){if(!t?.length)return!1;for(let n=0;n<t.length;n++){const a=t[n];if(!a?.shape)continue;const s=a.transform,r=s&&!s.isIdentity();r&&(e.save(),e.transform(s.a,s.b,s.c,s.d,s.tx,s.ty)),A(e,a.shape),r&&e.restore()}return!0}B.extension={type:[s.CanvasPipes],name:"colorMask"};class W{constructor(e){this._warnedMaskTypes=new Set,this._canvasMaskStack=[],this._renderer=e}push(e,t,n){this._renderer.renderPipes.batch.break(n),n.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:e,inverse:t._maskOptions.inverse,canBundle:!1})}pop(e,t,n){this._renderer.renderPipes.batch.break(n),n.add({renderPipeId:"stencilMask",action:"popMaskEnd",mask:e,inverse:t._maskOptions.inverse,canBundle:!1})}execute(e){if("pushMaskBegin"!==e.action&&"popMaskEnd"!==e.action)return;const t=this._renderer,n=t.canvasContext,a=n?.activeContext;if(!a)return;if("popMaskEnd"===e.action){return void(this._canvasMaskStack.pop()&&a.restore())}e.inverse&&this._warnOnce("inverse","CanvasRenderer: inverse masks are not supported on Canvas2D; ignoring inverse flag.");const s=e.mask.mask;if(!(s instanceof S))return this._warnOnce("nonGraphics","CanvasRenderer: only Graphics masks are supported in Canvas2D; skipping mask."),void this._canvasMaskStack.push(!1);const r=s,o=r.context?.instructions;if(!o?.length)return void this._canvasMaskStack.push(!1);a.save(),n.setContextTransform(r.groupTransform,1===(t._roundPixels|r._roundPixels)),a.beginPath();let i=!1,l=!1;for(let c=0;c<o.length;c++){const e=o[c],t=e.action;if("fill"!==t&&"stroke"!==t)continue;const n=e.data,s=n?.path?.shapePath;if(!s?.shapePrimitives?.length)continue;const r=s.shapePrimitives;for(let o=0;o<r.length;o++){const e=r[o];if(!e?.shape)continue;const t=e.transform,n=t&&!t.isIdentity();n&&(a.save(),a.transform(t.a,t.b,t.c,t.d,t.tx,t.ty)),A(a,e.shape),l=E(a,e.holes)||l,i=!0,n&&a.restore()}}if(!i)return a.restore(),void this._canvasMaskStack.push(!1);l?a.clip("evenodd"):a.clip(),this._canvasMaskStack.push(!0)}destroy(){this._renderer=null,this._warnedMaskTypes=null,this._canvasMaskStack=null}_warnOnce(e,t){this._warnedMaskTypes.has(e)||(this._warnedMaskTypes.add(e),r(t))}}W.extension={type:[s.CanvasPipes],name:"stencilMask"};const H="source-over";const G=new a;class U{constructor(e){this.activeResolution=1,this.smoothProperty="imageSmoothingEnabled",this.blendModes=function(){const e=w(),t=Object.create(null);return t.inherit=H,t.none=H,t.normal="source-over",t.add="lighter",t.multiply=e?"multiply":H,t.screen=e?"screen":H,t.overlay=e?"overlay":H,t.darken=e?"darken":H,t.lighten=e?"lighten":H,t["color-dodge"]=e?"color-dodge":H,t["color-burn"]=e?"color-burn":H,t["hard-light"]=e?"hard-light":H,t["soft-light"]=e?"soft-light":H,t.difference=e?"difference":H,t.exclusion=e?"exclusion":H,t.saturation=e?"saturation":H,t.color=e?"color":H,t.luminosity=e?"luminosity":H,t["linear-burn"]=e?"color-burn":H,t["linear-dodge"]=e?"color-dodge":H,t["linear-light"]=e?"hard-light":H,t["pin-light"]=e?"hard-light":H,t["vivid-light"]=e?"hard-light":H,t["hard-mix"]=H,t.negation=e?"difference":H,t["normal-npm"]=t.normal,t["add-npm"]=t.add,t["screen-npm"]=t.screen,t.erase="destination-out",t.subtract=H,t.divide=H,t.min=H,t.max=H,t}(),this._activeBlendMode="normal",this._projTransform=null,this._outerBlend=!1,this._warnedBlendModes=new Set,this._renderer=e}resolutionChange(e){this.activeResolution=e}init(){const e=this._renderer.background.alpha<1;if(this.rootContext=this._renderer.canvas.getContext("2d",{alpha:e}),this.activeContext=this.rootContext,this.activeResolution=this._renderer.resolution,!this.rootContext.imageSmoothingEnabled){const e=this.rootContext;e.webkitImageSmoothingEnabled?this.smoothProperty="webkitImageSmoothingEnabled":e.mozImageSmoothingEnabled?this.smoothProperty="mozImageSmoothingEnabled":e.oImageSmoothingEnabled?this.smoothProperty="oImageSmoothingEnabled":e.msImageSmoothingEnabled&&(this.smoothProperty="msImageSmoothingEnabled")}}setContextTransform(e,t,n,s){const r=s?a.IDENTITY:this._renderer.globalUniforms.globalUniformData?.worldTransformMatrix||a.IDENTITY;let o=G;o.copyFrom(r),o.append(e);const i=this._projTransform,l=this.activeResolution;if(n=n||l,i){const e=a.shared;e.copyFrom(o),e.prepend(i),o=e}t?this.activeContext.setTransform(o.a*n,o.b*n,o.c*n,o.d*n,o.tx*l|0,o.ty*l|0):this.activeContext.setTransform(o.a*n,o.b*n,o.c*n,o.d*n,o.tx*l,o.ty*l)}clear(e,t){const n=this.activeContext,a=this._renderer;if(n.clearRect(0,0,a.width,a.height),e){const s=o.shared.setValue(e);n.globalAlpha=t??s.alpha,n.fillStyle=s.toHex(),n.fillRect(0,0,a.width,a.height),n.globalAlpha=1}}setBlendMode(e){if(this._activeBlendMode===e)return;this._activeBlendMode=e,this._outerBlend=!1;const t=this.blendModes[e];if(!t)return this._warnedBlendModes.has(e)||this._warnedBlendModes.add(e),void(this.activeContext.globalCompositeOperation="source-over");this.activeContext.globalCompositeOperation=t}destroy(){this.rootContext=null,this.activeContext=null,this._warnedBlendModes.clear()}}U.extension={type:[s.CanvasSystem],name:"canvasContext"};class j{constructor(){this.maxTextures=16,this.maxBatchableTextures=16,this.maxUniformBindings=0}init(){}}j.extension={type:[s.CanvasSystem],name:"limits"};const F=new a,q=new a,D=new a,O=new a;function L(e,t,n){e.beginPath();for(let a=0;a<n.length;a+=3){const s=2*n[a],r=2*n[a+1],o=2*n[a+2];e.moveTo(t[s],t[s+1]),e.lineTo(t[r],t[r+1]),e.lineTo(t[o],t[o+1]),e.closePath()}e.fill()}function N(e,t){switch(t.type){case"rectangle":{const n=t;e.rect(n.x,n.y,n.width,n.height);break}case"roundedRectangle":{const n=t;!function(e,t,n,a,s,r){r=Math.max(0,Math.min(r,Math.min(a,s)/2)),e.moveTo(t+r,n),e.lineTo(t+a-r,n),e.quadraticCurveTo(t+a,n,t+a,n+r),e.lineTo(t+a,n+s-r),e.quadraticCurveTo(t+a,n+s,t+a-r,n+s),e.lineTo(t+r,n+s),e.quadraticCurveTo(t,n+s,t,n+s-r),e.lineTo(t,n+r),e.quadraticCurveTo(t,n,t+r,n)}(e,n.x,n.y,n.width,n.height,n.radius);break}case"circle":{const n=t;e.arc(n.x,n.y,n.radius,0,2*Math.PI);break}case"ellipse":{const n=t;e.ellipse?e.ellipse(n.x,n.y,n.halfWidth,n.halfHeight,0,0,2*Math.PI):(e.save(),e.translate(n.x,n.y),e.scale(n.halfWidth,n.halfHeight),e.arc(0,0,1,0,2*Math.PI),e.restore());break}case"triangle":{const n=t;e.moveTo(n.x,n.y),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3),e.closePath();break}default:{const n=t,a=n.points;if(!a?.length)break;e.moveTo(a[0],a[1]);for(let t=2;t<a.length;t+=2)e.lineTo(a[t],a[t+1]);n.closePath&&e.closePath();break}}}function Y(e,t){if(!t?.length)return!1;for(let n=0;n<t.length;n++){const a=t[n];if(!a?.shape)continue;const s=a.transform,r=s&&!s.isIdentity();r&&(e.save(),e.transform(s.a,s.b,s.c,s.d,s.tx,s.ty)),N(e,a.shape),r&&e.restore()}return!0}function V(e,t,n,a){const s=e.fill;if(s instanceof d){s.buildGradient();const r=s.texture;if(r){const o=M.getTintedPattern(r,t),i=n?O.copyFrom(n).scale(r.source.pixelWidth,r.source.pixelHeight):O.copyFrom(s.transform);return a&&!e.textureSpace&&i.append(a),M.applyPatternTransform(o,i),o}}if(s instanceof u){const e=M.getTintedPattern(s.texture,t);return M.applyPatternTransform(e,s.transform),e}const r=e.texture;if(r&&r!==i.WHITE){if(!r.source.resource)return"#808080";const a=M.getTintedPattern(r,t),s=n?O.copyFrom(n).scale(r.source.pixelWidth,r.source.pixelHeight):e.matrix;return M.applyPatternTransform(a,s),a}return`#${(16777215&t).toString(16).padStart(6,"0")}`}class X{constructor(){this.shader=null}contextChange(e){}execute(a,s){const r=a.renderer,o=r.canvasContext,d=o.activeContext,u=s.groupTransform,p=r.globalUniforms.globalUniformData?.worldColor??4294967295,m=s.groupColorAlpha,g=(p>>>24&255)/255*((m>>>24&255)/255)*(r.filter?.alphaMultiplier??1);if(g<=0)return;const x=t(n(16777215&m,16777215&p)),f=r._roundPixels|s._roundPixels;d.save(),o.setContextTransform(u,1===f),o.setBlendMode(s.groupBlendMode);const v=s.context.instructions;for(let t=0;t<v.length;t++){const a=v[t];if("texture"===a.action){const t=a.data,s=t.image,r=s?M.getCanvasSource(s):null;if(!r)continue;const i=t.alpha*g;if(i<=0)continue;const l=n(t.style,x);d.globalAlpha=i;let c=r;16777215!==l&&(c=M.getTintedCanvas({texture:s},l));const h=s.frame,p=s.source._resolution??s.source.resolution??1;let m=h.x*p,v=h.y*p;const y=h.width*p,T=h.height*p;c!==r&&(m=0,v=0);const C=t.transform,_=C&&!C.isIdentity(),k=s.rotate;_||k?(F.copyFrom(u),_&&F.append(C),k&&e.matrixAppendRotationInv(F,k,t.dx,t.dy,t.dw,t.dh),o.setContextTransform(F,1===f)):o.setContextTransform(u,1===f),d.drawImage(c,m,v,c===r?y:c.width,c===r?T:c.height,k?0:t.dx,k?0:t.dy,t.dw,t.dh),(_||k)&&o.setContextTransform(u,1===f);continue}const s=a.data,r=s?.path?.shapePath;if(!r?.shapePrimitives?.length)continue;const p=s.style,m=n(p.color,x),y=p.alpha*g;if(y<=0)continue;const T="stroke"===a.action;if(d.globalAlpha=y,T){const e=p;d.lineWidth=e.width,d.lineCap=e.cap,d.lineJoin=e.join,d.miterLimit=e.miterLimit}const C=r.shapePrimitives;if(!T&&s.hole?.shapePath?.shapePrimitives?.length){C[C.length-1].holes=s.hole.shapePath.shapePrimitives}for(let e=0;e<C.length;e++){const t=C[e];if(!t?.shape)continue;const n=t.transform,a=n&&!n.isIdentity(),s=p.texture&&p.texture!==i.WHITE,r="global"===p.textureSpace?n:null,o=V(p,m,s?l(q,p,t.shape,r):null,a?D.copyFrom(u).append(n):u);if(a&&(d.save(),d.transform(n.a,n.b,n.c,n.d,n.tx,n.ty)),T){const e=p;if(.5!==e.alignment&&!e.pixelLine){const n=[],a=[],s=[],r=c[t.shape.type];if(r?.build(t.shape,n)){const r=t.shape.closePath??!0;h(n,e,!1,r,a,s),d.fillStyle=o,L(d,a,s)}else d.strokeStyle=o,d.beginPath(),N(d,t.shape),d.stroke()}else d.strokeStyle=o,d.beginPath(),N(d,t.shape),d.stroke()}else{d.fillStyle=o,d.beginPath(),N(d,t.shape);Y(d,t.holes)?d.fill("evenodd"):d.fill()}a&&d.restore()}}d.restore()}destroy(){this.shader=null}}X.extension={type:[s.CanvasPipesAdaptor],name:"graphics"};class z{init(e,t){this._renderer=e,this._renderTargetSystem=t}initGpuRenderTarget(e){const t=e.colorTexture,{canvas:n,context:a}=this._ensureCanvas(t);return{canvas:n,context:a,width:n.width,height:n.height}}resizeGpuRenderTarget(e){const t=e.colorTexture,{canvas:n}=this._ensureCanvas(t);n.width=e.pixelWidth,n.height=e.pixelHeight}startRenderPass(e,t,n,a){const s=this._renderTargetSystem.getGpuRenderTarget(e);this._renderer.canvasContext.activeContext=s.context,this._renderer.canvasContext.activeResolution=e.resolution,t&&this.clear(e,t,n,a)}clear(e,t,n,a){const s=this._renderTargetSystem.getGpuRenderTarget(e).context,r=a||{x:0,y:0,width:e.pixelWidth,height:e.pixelHeight};if(s.setTransform(1,0,0,1,0,0),s.clearRect(r.x,r.y,r.width,r.height),n){const e=o.shared.setValue(n);e.alpha>0&&(s.globalAlpha=e.alpha,s.fillStyle=e.toHex(),s.fillRect(r.x,r.y,r.width,r.height),s.globalAlpha=1)}}finishRenderPass(){}copyToTexture(e,t,n,a,s){const r=this._renderTargetSystem.getGpuRenderTarget(e).canvas,o=t.source,{context:i}=this._ensureCanvas(o),l=s?.x??0,c=s?.y??0;return i.drawImage(r,n.x,n.y,a.width,a.height,l,c,a.width,a.height),o.update(),t}destroyGpuRenderTarget(e){}_ensureCanvas(e){let t=e.resource;t&&p.test(t)||(t=m.get().createCanvas(e.pixelWidth,e.pixelHeight),e.resource=t),t.width===e.pixelWidth&&t.height===e.pixelHeight||(t.width=e.pixelWidth,t.height=e.pixelHeight);const n=t.getContext("2d");return{canvas:t,context:n}}}class J extends v{constructor(e){super(e),this.adaptor=new z,this.adaptor.init(e,this)}}J.extension={type:[s.CanvasSystem],name:"renderTarget"};class Q{constructor(e){}init(){}initSource(e){}generateCanvas(e){const t=m.get().createCanvas(),n=t.getContext("2d"),a=M.getCanvasSource(e);if(!a)return t;const s=e.frame,r=e.source._resolution??e.source.resolution??1,o=s.x*r,i=s.y*r,l=s.width*r,c=s.height*r;return t.width=Math.ceil(l),t.height=Math.ceil(c),n.drawImage(a,o,i,l,c,0,0,l,c),t}getPixels(e){const t=this.generateCanvas(e);return{pixels:t.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,t.width,t.height).data,width:t.width,height:t.height}}destroy(){}}Q.extension={type:[s.CanvasSystem],name:"texture"};const K=[...y,U,j,Q,J],$=[T,C,_,k,b,W,B,P],Z=[R,X],ee=[],te=[],ne=[];f.handleByNamedList(s.CanvasSystem,ee),f.handleByNamedList(s.CanvasPipes,te),f.handleByNamedList(s.CanvasPipesAdaptor,ne),f.add(...K,...$,...Z);class ae extends g{constructor(){super({name:"canvas",type:x.CANVAS,systems:ee,renderPipes:te,renderPipeAdaptors:ne})}}export{ae as CanvasRenderer};
